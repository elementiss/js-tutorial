<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>( regular-expressions-js-flems.md )</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
  <!--

  /* RESET
  =============================================================================*/

  html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, 
      abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, 
      strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, 
      legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, 
      embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, 
      section, summary, time, mark, audio, video {
    margin: 0;
    padding: 0;
    border: 0;
  }

  /* BODY
  =============================================================================*/

  body {
    font-family: Arimo, Nunito Sans, arial, clean, sans-serif;
    font-size: 16px;
    line-height: 1.5;  /* межстрочное */
    color: #333;
    background-color: #fff;
    padding: 20px;
    max-width: 34em; /* ширина текста */
    margin: 0 auto;
  }

  body>*:first-child {
    margin-top: 0 !important;
  }

  body>*:last-child {
    margin-bottom: 0 !important;
  }

  /* BLOCKS
  =============================================================================*/

  p, blockquote, ul, ol, dl, table, pre {
    margin: 0.4em 0; /* между абзацами (кроме первого и последнего) */
  }

  /* HEADERS
  =============================================================================*/

  h1, h2, h3, h4, h5, h6 {
    margin: 20px 0 10px;
    padding: 0;
    font-family: Opinion Pro, Neucha;
    font-weight: bold;
    -webkit-font-smoothing: antialiased;
    text-shadow: 0px 0px 10px rgb(0 0 0 / 25%);
  }

  h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
    font-size: 1em;
  }

  h1 {
    font-size: 1.8em;
    /*color: #000;*/
  }

  h2 {
    font-size: 1.5em;
    border-bottom: 1px solid #ccc;
    /*color: #000;*/
  }

  h3 {
    font-size: 1.3em;
  }

  h4 {
    font-size: 1.1em;
  }

  h5 {
    font-size: 1.1em;
  }

  h6 {
    /*color: #777;*/
    font-size: 1.0em;
  }

  body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
    margin-top: 0;
    padding-top: 0;
  }

  a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
  }

  h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
    margin-top: 10px;
  }

  /* LINKS
  =============================================================================*/

  a {
    color: #4183C4;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  /* LISTS
  =============================================================================*/

  ul, ol {
    padding-left: 30px;
  }

  ul li > :first-child, 
  ol li > :first-child, 
  ul li ul:first-of-type, 
  ol li ol:first-of-type, 
  ul li ol:first-of-type, 
  ol li ul:first-of-type {
    margin-top: 0px;
  }

  ul ul, ul ol, ol ol, ol ul {
    margin-bottom: 0;
  }

  dl {
    padding: 0;
  }

  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px;
  }

  dl dt:first-child {
    padding: 0;
  }

  dl dt>:first-child {
    margin-top: 0px;
  }

  dl dt>:last-child {
    margin-bottom: 0px;
  }

  dl dd {
    margin: 0 0 15px;
    padding: 0 15px;
  }

  dl dd>:first-child {
    margin-top: 0px;
  }

  dl dd>:last-child {
    margin-bottom: 0px;
  }

  /* CODE
  =============================================================================*/

  pre, code, tt {
    font-size: 1rem;
    font-family: Iosevka, Consolas, "Liberation Mono", Courier, monospace;
  }

  code, tt {
    margin: 0 0px;
    padding: 1px 3px;
    white-space: nowrap;
    border: 1px solid #eaeaea;
  /*   background-color: #f8f8f8; это `code` */
    background-color: #EFFFEF;
    border-radius: 3px;
  }

  pre>code {
    margin: 0;
    padding: 0;
    white-space: pre;
    border: none;
    background: transparent; 
  }

  .sourceCode{
    background-color: #F6FFF7; /* светло-зелен для блоков кода */
    font-size: 100%;
  }
    div.sourceCode{
       box-shadow: 0px 0px 15px rgb(0 0 0 / 7%);
    }

  pre {
  /*   background-color: #f8f8f8; это ``` */
    border: 1px solid #ccc;
    font-size: 14px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 8px;
    border-radius: 3px;
  }

  pre code, pre tt {
    background-color: transparent; 
    border: none;
  }

  kbd {
      -moz-border-bottom-colors: none;
      -moz-border-left-colors: none;
      -moz-border-right-colors: none;
      -moz-border-top-colors: none;
      background-color: #DDDDDD;
      background-image: linear-gradient(#F1F1F1, #DDDDDD);
      background-repeat: repeat-x;
      border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
      border-image: none;
      border-radius: 2px 2px 2px 2px;
      border-style: solid;
      border-width: 1px;
      font-family: Iosevka, Helvetica, Arial, sans-serif;
      line-height: 10px;
      padding: 1px 4px;
      box-shadow: 0 1px 0 rgba(63,63,63,0.25);
  }

  /* QUOTES
  =============================================================================*/

  blockquote {
    border-left: 4px solid #DDD;
    padding: 0 15px;
    color: #777;
  }

  blockquote>:first-child {
    margin-top: 0px;
  }

  blockquote>:last-child {
    margin-bottom: 0px;
  }

  /* HORIZONTAL RULES
  =============================================================================*/

  hr {
    clear: both;
    margin: 15px 0;
    height: 0px;
    overflow: hidden;
    border: none;
    background: transparent;
    border-bottom: 2px dotted #777;
    padding: 0;
  }

  /* TABLES
  =============================================================================*/

    table {                                     
       box-shadow: 0px 0px 15px rgb(0 0 0 / 15%);
       display: inline-block;
       width: auto;
    }

  table th {
    font-weight: bold;
  }

  table th, table td {
    border: 1px solid #ccc;
    padding: 6px 13px;
    font-size: 1rem;
  }

  table tr {
    border-top: 1px solid #ccc;
    background-color: #fff;
  }

  table tr:nth-child(2n) {
    background-color: #f8f8f8;
  }

  /* IMAGES
  =============================================================================*/

  img {
    max-width: 100%
  }

    .footnote-back, .footnote-ref {
      color: #4493f8 !important; /* blue */
    }
    .footnote-ref, .footnote-ref::after {
      font-size: 0.95em;
      font-weight: 700;
      vertical-align: super; 
    }
    .footnote-ref::after {
      content:")";
    }
    .footnotes-end-of-document  {
      font-size: 0.85em;  
    }

    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 1.5em;
      margin: 0 0.8em 0.2em -1.8em;
      vertical-align: middle;
    }

    .note, .tip, .warning { 
      border-left-style: solid;
      border-left-width: 3px;
      padding-left: 7px;
    }
    div.title {
      font-size: 0.85em;
      font-weight: bold;
    }
    div.title > p::before{
       content: '#';
       width: 1em; 
       height: 1em; 
       display: inline-block; 
    }



    .note > .title {
       color: #4493f8; /* blue */
    }   
    .tip > .title {
       color: #3fb950; /* green */
    }
    .warning > .title {
       color: #d29922 /* olive */;
    }
    .note  {
       border-color: #4493f8; /* blue */
    }
    .tip  {
       border-color: #3fb950; /* green */ 
    }
    .warning {
       border-color: #d29922 /* olive */; 
    }


  #TOC {
     font-family: Opinion Pro;
     font-weight: bold;
     font-size: 0.9em;
     padding-left: 1em;
     padding: .2em 0 .2em 1.0em;
     background: #f7f7f7;
     border: dashed 1px rgb(128,128,128); /* grey */
     box-shadow: 0px 0px 0.8em rgb(0 0 0 / 25%);
  }

    figure {
      margin: 0.3em 0 0.9em;
      background-color: #eee;
  /*  text-align: center; */
      box-shadow: 0px 0px 0.8em rgb(0 0 0 / 25%);
      border: dashed 1px rgb(128,128,128); /* grey */
    }

    figcaption {
      font-family: Iosevka, Bitter;
      font-style: italic;
      font-size: 95%;
      background-color: #eee;
      color: #000;
      padding: 0em 1em .2em;
      margin: 0;
    }

    figure:hover{
      background: #fff;
    }

    figure:hover figcaption {
      background: #fff;
    }


  -->
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">( regular-expressions-js-flems.md )</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#регулярні-вирази-javascript"
id="toc-регулярні-вирази-javascript">Регулярні вирази JavaScript</a>
<ul>
<li><a href="#способи-створення-регулярних-виразів"
id="toc-способи-створення-регулярних-виразів">Способи створення
регулярних виразів</a></li>
<li><a href="#модифікатори-регулярних-виразів"
id="toc-модифікатори-регулярних-виразів">Модифікатори регулярних
виразів</a></li>
<li><a href="#набори-та-діапазони" id="toc-набори-та-діапазони">Набори
та діапазони</a></li>
<li><a href="#метасимволи-або-символьні-класи"
id="toc-метасимволи-або-символьні-класи">Метасимволи або символьні
класи</a></li>
<li><a href="#крапка---це-будь-який-символ"
id="toc-крапка---це-будь-який-символ">Крапка - це будь-який
символ</a></li>
<li><a href="#межа-слова" id="toc-межа-слова">Межа слова</a></li>
<li><a href="#якоря-початок-та-кінець-рядка"
id="toc-якоря-початок-та-кінець-рядка">Якоря: початок та кінець
рядка</a></li>
<li><a href="#квантифікатори"
id="toc-квантифікатори">Квантифікатори</a></li>
<li><a href="#методи-рядків" id="toc-методи-рядків">Методи рядків</a>
<ul>
<li><a href="#str.match" id="toc-str.match">str.match</a></li>
<li><a href="#str.matchall" id="toc-str.matchall">str.matchAll</a></li>
<li><a href="#str.search" id="toc-str.search">str.search</a></li>
<li><a href="#str.replace" id="toc-str.replace">str.replace</a></li>
</ul></li>
<li><a href="#методи-regexp" id="toc-методи-regexp">Методи RegExp</a>
<ul>
<li><a href="#regexp.test" id="toc-regexp.test">regexp.test</a></li>
<li><a href="#regexp.exec" id="toc-regexp.exec">regexp.exec</a></li>
</ul></li>
<li><a href="#тестування-регулярних-виразів"
id="toc-тестування-регулярних-виразів">Тестування регулярних
виразів</a></li>
<li><a href="#повний-довідник-з-регулярних-виразів"
id="toc-повний-довідник-з-регулярних-виразів">Повний довідник з
регулярних виразів</a></li>
<li><a href="#корисні-практичні-приклади"
id="toc-корисні-практичні-приклади">Корисні практичні приклади</a>
<ul>
<li><a href="#замінити-множинні-пробіли-на-один"
id="toc-замінити-множинні-пробіли-на-один">Замінити множинні пробіли на
один</a></li>
<li><a href="#витяг-певних-даних-із-рядка"
id="toc-витяг-певних-даних-із-рядка">Витяг певних даних із
рядка</a></li>
</ul></li>
<li><a href="#faq-за-регулярними-виразами"
id="toc-faq-за-регулярними-виразами">FAQ за регулярними виразами</a>
<ul>
<li><a href="#у-чому-різниця-між-match-та-exec"
id="toc-у-чому-різниця-між-match-та-exec">У чому різниця між match() та
exec()?</a></li>
<li><a href="#як-зробити-групу-незахоплюючою"
id="toc-як-зробити-групу-незахоплюючою">Як зробити групу
незахоплюючою?</a></li>
<li><a
href="#як-обробляти-помилки-під-час-роботи-з-регулярними-виразами"
id="toc-як-обробляти-помилки-під-час-роботи-з-регулярними-виразами">Як
обробляти помилки під час роботи з регулярними виразами?</a></li>
<li><a href="#чому-потрібно-екранувати-спецсимволи"
id="toc-чому-потрібно-екранувати-спецсимволи">Чому потрібно екранувати
спецсимволи?</a></li>
<li><a href="#у-чому-відмінність-крапки-від-ss"
id="toc-у-чому-відмінність-крапки-від-ss">У чому відмінність крапки від
\s\S</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="регулярні-вирази-javascript">Регулярні вирази JavaScript</h1>
<p>Регулярні вирази JavaScript — це потужний інструмент для роботи з
текстом, що дозволяє шукати, перевіряти, витягувати і змінювати рядки за
заданими шаблонами. Вони часто використовуються для таких завдань, як
валідація даних (наприклад, перевірка адрес електронної пошти або
номерів телефонів), пошук і заміна фрагментів тексту, а також отримання
інформації, що відповідає певним критеріям (наприклад, дати, ключові
слова).</p>

<pre><code class=language-js>console.log("Hello");</code></pre>


<p>Використання регулярних виразів допомагає скоротити код та спростити
обробку тексту.</p>
<p>У JavaScript регулярні вирази реалізовані окремим об'єктом
<code>RegExp</code> і інтегровані в методи роботи з рядками.</p>
<h2 id="способи-створення-регулярних-виразів">Способи створення
регулярних виразів</h2>
<p><strong>Регулярний вираз</strong> — це послідовність символів, яка
визначає правила пошуку. Він складається з шаблону та необов’язкових
модифікаторів.</p>
<p>Без модифікаторів і спеціальних символів, які ми розглянемо пізніше,
пошук за регулярним виразом аналогічний пошуку підрядка.</p>
<p>У JavaScript є два основні способи створення регулярних виразів:</p>
<ul>
<li>Літеральна нотація (за допомогою слешів)</li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/pattern/modifiers</span><span class="op">;</span> <span class="co">// синтаксис </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex1 <span class="op">=</span> <span class="ss">/hello/</span><span class="op">;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex2 <span class="op">=</span> <span class="ss">/</span><span class="sc">[a-z]</span><span class="ss">/gi</span><span class="op">;</span> </span></code></pre></div>
<ul>
<li>Конструктор <code>RegExp</code></li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex1 <span class="op">=</span> <span class="kw">new</span> <span class="bu">RegExp</span>(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex3 <span class="op">=</span> <span class="kw">new</span> <span class="bu">RegExp</span>(<span class="st">&quot;[a-z]&quot;</span><span class="op">,</span> <span class="st">&quot;gi&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Літеральну нотацію зручно використовувати, коли шаблон відомий
заздалегідь і не змінюється — а це більшість ситуацій. Слеші
<code>/.../</code> повідомляють JavaScript, що це регулярний вираз. Вони
виконують таку ж роль, як лапки для рядків.</p>
<p>Конструктор <code>RegExp</code> дозволяє створювати регулярні вирази
динамічно, «на льоту», наприклад, коли шаблон чи модифікатори задає
користувач.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tag <span class="op">=</span> <span class="fu">prompt</span>(<span class="st">&quot;Який тег ви хочете знайти?&quot;</span><span class="op">,</span> <span class="st">&quot;h2&quot;</span>)<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="kw">new</span> <span class="bu">RegExp</span>(<span class="vs">`&lt;</span><span class="sc">${</span>tag<span class="sc">}</span><span class="vs">&gt;`</span>)<span class="op">;</span> </span></code></pre></div>
<p>Якщо користувач відповість на prompt рядком "h2", то вийде регулярний
вираз <code>/&lt;h2&gt;/</code>.</p>
<h2 id="модифікатори-регулярних-виразів">Модифікатори регулярних
виразів</h2>
<p>Регулярні вирази можуть мати модифікатори, які змінюють поведінку
виразу чи надають додаткову інформацію.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr>
<th>Модифікатор</th>
<th>Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>i</strong></td>
<td>Виконує пошук без врахування регістру: немає різниці між
<code>A</code> та <code>a</code>.</td>
</tr>
<tr>
<td><strong>g</strong></td>
<td>Шукає всі збіги, а не лише перший (глобальний пошук).</td>
</tr>
<tr>
<td><strong>m</strong></td>
<td>Вмикає багаторядковий режим (multiline).</td>
</tr>
<tr>
<td><strong>y</strong></td>
<td>Шукає лише з певної позиції (sticky).</td>
</tr>
<tr>
<td><strong>u</strong></td>
<td>Вмикає повну підтримку Unicode. Забезпечує правильну обробку
сурогатних пар.</td>
</tr>
<tr>
<td><strong>s</strong></td>
<td>Дозволяє крапці (<code>.</code>) відповідати символу нового рядка
(режим dotall).</td>
</tr>
<tr>
<td><strong>d</strong></td>
<td>Дозволяє отримувати інформацію про позиції збігів у рядку (новинка в
ES2022). Додає властивість-масив <strong>indices</strong> до результату
з індексами початку і кінця підрядків.</td>
</tr>
</tbody>
</table>
<p>Модифікатори можна вказувати двома способами:</p>
<ul>
<li>Після закриваючого слешу: <code>/pattern/flags</code>.</li>
<li>У конструкторі <strong>RegExp</strong>:</li>
</ul>
<div class="sourceCode" id="cb4"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Обидва варіанти еквівалентні</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex1 <span class="op">=</span> <span class="ss">/hello/gi</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex2 <span class="op">=</span> <span class="kw">new</span> <span class="bu">RegExp</span>(<span class="st">&#39;hello&#39;</span><span class="op">,</span> <span class="st">&#39;gi&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p>Модифікатори можна комбінувати:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> text <span class="op">=</span> <span class="st">&quot;Hello HELLO hello&quot;</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(text<span class="op">.</span><span class="fu">match</span>(<span class="ss">/hello/gi</span>))<span class="op">;</span> <span class="co">// [&#39;Hello&#39;, &#39;HELLO&#39;, &#39;hello&#39;]</span></span></code></pre></div>
<iframe src="examples/ex1.html" width="100%" height="200" frameborder="0">
</iframe>
<p><strong>Приклади</strong></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="ss">/hello/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;HELLO&#39;</span>))<span class="op">;</span> <span class="co">// false</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="ss">/hello/i</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;HELLO&#39;</span>))<span class="op">;</span> <span class="co">// true</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;hello hello&#39;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/hello/</span>) <span class="co">// &#39;hello&#39;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;hello hello&#39;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/hello/g</span>) <span class="co">// [&#39;hello&#39;, &#39;hello&#39;]</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&#39;line1</span><span class="sc">\n</span><span class="st">line2&#39;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">line/g</span>))<span class="op">;</span> <span class="co">// [ &#39;line&#39; ]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&#39;line1</span><span class="sc">\n</span><span class="st">line2&#39;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">line/gm</span>))<span class="op">;</span> <span class="co">// [&#39;line&#39;, &#39;line&#39;]</span></span></code></pre></div>
<iframe src="examples/ex8.html" width="100%" height="450" frameborder="0">
</iframe>
<div class="sourceCode" id="cb9"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiline <span class="op">=</span> <span class="vs">`First line</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="vs">Second line</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="vs">Third line`</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ^ и $ тепер працюють для кожного рядка</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(multiline<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">Second/</span>))<span class="op">;</span>  <span class="co">// null</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(multiline<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">Second/m</span>))<span class="op">;</span> <span class="co">// [&#39;Second&#39;]</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex <span class="op">=</span> <span class="ss">/</span><span class="sc">\d</span><span class="ss">/y</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>regex<span class="op">.</span><span class="at">lastIndex</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;a1b2&#39;</span><span class="op">.</span><span class="fu">match</span>(regex) <span class="co">// [&#39;1&#39;]</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>regex<span class="op">.</span><span class="at">lastIndex</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;a1b2&#39;</span><span class="op">.</span><span class="fu">match</span>(regex) <span class="co">// &#39;2&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/</span><span class="sc">\u</span><span class="ss">{1F600}/u</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;😀&#39;</span>) <span class="co">// true</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">.</span><span class="sc">$</span><span class="ss">/u</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;😀&#39;</span>))<span class="op">;</span> <span class="co">// true</span></span></code></pre></div>
<iframe src="examples/ex2.html" width="100%" height="200" frameborder="0">
</iframe>
<div class="sourceCode" id="cb12"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;Hello World&quot;</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/World/d</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result <span class="op">=</span> regexp<span class="op">.</span><span class="fu">exec</span>(str)<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(result<span class="op">.</span><span class="at">indices</span>[<span class="dv">0</span>])<span class="op">;</span> <span class="co">// [6, 11]</span></span></code></pre></div>
<p>Output: 6 - початкова позиція збігу, 11 - кінцева позиція збігу.</p>
<iframe src="examples/ex5.html" width="100%" frameborder="0">
</iframe>
<p>Модифікатор <code>d</code> корисний, коли потрібно:</p>
<ul>
<li>Визначати точне положення збігів у тексті</li>
<li>Підсвічувати знайдений текст</li>
<li>Створювати парсери</li>
</ul>
<p>Важливо знати:</p>
<p>Модифікатори можуть суттєво впливати на продуктивність
регулярних<br />
виразів, особливо під час роботи з великими текстами.</p>
<h2 id="набори-та-діапазони">Набори та діапазони</h2>
<p>Кілька символів або символьних класів у квадратних дужках
<code>[…]</code><br />
означають «шукати будь-який символ із заданих».</p>
<p>Наприклад, <code>[eao]</code> означає будь-який із трьох символів:
'a', 'e' або<br />
'o'. Це називається <em>набором</em>.</p>
<p>Зверніть увагу, що в наборі кілька символів, але в результаті
він<br />
відповідає рівно одному символу.</p>
<p>У квадратних дужках можна вказувати <em>діапазони</em>, наприклад,
<code>[a-z]</code><br />
відповідає символу в діапазоні від a до z, або <code>[0-5]</code> —
цифра від 0<br />
до 5.</p>
<p>У <code>[0-9A-F]</code> одразу два діапазони: шукається символ, який
або цифра від 0<br />
до 9, або літера від A до F.</p>
<p>Якщо ми хочемо знайти літери як у верхньому, так і в нижньому
регістрі, то можемо<br />
додати діапазон: <code>[0-9A-Fa-f]</code>. Або встановити у регулярному
виразі<br />
модифікатор <code>i</code>.</p>
<table>
<thead>
<tr>
<th>Вираз</th>
<th>Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[abc]</code></td>
<td>Знайти будь-який із символів у дужках</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>Знайти будь-який символ, крім вказаних у дужках</td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td>Знайти будь-яку цифру у дужках від 0 до 9</td>
</tr>
<tr>
<td><code>(x\|y)</code></td>
<td>Знайти будь-яку з альтернатив, розділених знаком
<code>\|</code></td>
</tr>
</tbody>
</table>
<h2 id="метасимволи-або-символьні-класи">Метасимволи або символьні
класи</h2>
<p>Символьні класи - це лише скорочення для наборів символів.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 5%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr>
<th>Клас</th>
<th>Еквівалент</th>
<th>Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\d</code></td>
<td><code>[0-9]</code></td>
<td>цифра від 0 до 9</td>
</tr>
<tr>
<td><code>\w</code></td>
<td><code>[a-zA-Z0-9_]</code></td>
<td>символ слова</td>
</tr>
<tr>
<td><code>\s</code></td>
<td><code>[ \t\n\v\f\r]</code></td>
<td>пробільний символ, плюс кілька рідкісних символів пробілів
Юнікоду</td>
</tr>
<tr>
<td><code>\D</code></td>
<td><code>[^\d]</code></td>
<td>будь-який символ, крім цифри</td>
</tr>
<tr>
<td><code>\W</code></td>
<td><code>[^\w]</code></td>
<td>будь-який символ, крім <code>\w</code>, тобто не літери та не цифри
та не знак підкреслення</td>
</tr>
<tr>
<td><code>\S</code></td>
<td><code>[^\s]</code></td>
<td>будь-який непробільний символ</td>
</tr>
</tbody>
</table>
<p>Для прикладу, <code>\d\s\w</code> позначає цифру, за якою йде символ
пробілу, а потім символ слова, наприклад <code>1 a</code>.</p>
<p>Знайдемо першу цифру в номері телефону:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;+1(900)-123-45-67&quot;</span><span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/</span><span class="sc">\d</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str<span class="op">.</span><span class="fu">match</span>(regexp))<span class="op">;</span> <span class="co">// 1</span></span></code></pre></div>
<iframe src="examples/ex3.html" width="100%" height="200" frameborder="0">
</iframe>
<p>Давайте додамо модифікатор <code>g</code>, щоб знайти всі цифри:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;+1(900)-123-45-67&quot;</span><span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/</span><span class="sc">\d</span><span class="ss">/g</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str<span class="op">.</span><span class="fu">match</span>(regexp))<span class="op">;</span> </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">// масив збігів: 1,9,0,0,1,2,3,4,5,6,7</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">// можна зробити з них чисто цифровий номер телефону</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str<span class="op">.</span><span class="fu">match</span>(regexp)<span class="op">.</span><span class="fu">join</span>(<span class="st">&#39;&#39;</span>) )<span class="op">;</span> <span class="co">// 19001234567</span></span></code></pre></div>
<iframe src="examples/ex4.html" width="100%" height="250" frameborder="0">
</iframe>
<p>Альтернативний, більш короткий шлях - знайти нецифрові символи
<code>\D</code> і видалити їх з рядка:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;+1(900)-123-45-67&quot;</span><span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\D</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&quot;&quot;</span>))<span class="op">;</span> <span class="co">// 19001234567</span></span></code></pre></div>
<iframe src="examples/ex6.html" width="100%" height="200" frameborder="0">
</iframe>
<p>Важливо знати:</p>
<p>Всередині наборів символів метасимвол <code>'|'</code> сприймається
як типовий знак. Наприклад, <code>[bak|bok|buk]</code> означає рівно те
саме, що і <code>[baouk|]</code>.</p>
<p>Регулярний вираз може містити як звичайні символи, і символьні
класи.</p>
<h2 id="крапка---це-будь-який-символ">Крапка - це будь-який символ</h2>
<p>Крапка <code>.</code> - це спеціальний символьний клас, який
відповідає "будь-якому символу, крім нового рядка".</p>
<p>Зверніть увагу, що крапка означає будь-який символ, але не
відсутність символу.</p>
<h2 id="межа-слова">Межа слова</h2>
<p>Є три види позицій, які є межами слова:</p>
<ul>
<li>Початок тексту, якщо його перший символ <code>\w</code>.</li>
<li>Позиція всередині тексту, якщо ліворуч знаходиться <code>\w</code>,
а праворуч — не <code>\w</code>, або навпаки.</li>
<li>Кінець тексту, якщо його останній символ <code>\w</code>.</li>
</ul>
<p>Наприклад, регулярний вираз <code>\bJava\b</code> буде знайдено у
рядку<br />
<code>Hello, Java!</code>, де <code>Java</code> — окреме слово, але не
буде знайдено у рядку <code>Hello, JavaScript!</code>.</p>
<p>Ми можемо використовувати <code>\b</code> не тільки зі словами, але й
із цифрами.</p>
<p>Наприклад, регулярний вираз <code>\b\d\d\b</code> шукає окремо
розташовані числа. Іншими словами, він вимагає, щоб і до і після
<code>\d\d</code> були символи, відмінні від <code>\w</code>, такі як
пробіли або пунктуація (або початок/кінець тексту).</p>
<p><strong>Приклад</strong></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( <span class="st">&quot;1 23 456 78&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">\b\d\d\b</span><span class="ss">/g</span>))<span class="op">;</span> <span class="co">// [ &#39;23&#39;, &#39;78&#39; ]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( <span class="st">&quot;12,34,56&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">\b\d\d\b</span><span class="ss">/g</span>))<span class="op">;</span> <span class="co">// [ &#39;12&#39;, &#39;34&#39;, &#39;56&#39; ]</span></span></code></pre></div>
<iframe src="examples/ex7.html" width="100%" height="200" frameborder="0">
</iframe>
<p>Можна думати про <code>\b</code> як про символ нульової ширини,
вставлений автоматично в потрібних місцях. При цьому у результаті їх не
видно (вони ж нульової ширини), хоча відповідність шаблону є.</p>
<h2 id="якоря-початок-та-кінець-рядка">Якоря: початок та кінець
рядка</h2>
<p>Символи <code>^</code> та <code>$</code> мають спеціальні значення в
регулярних виразах. Вони називаються «якорі» (anchors).</p>
<p><code>^</code> означає збіг з початком тексту, а <code>$</code> — з
кінцем.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr>
<th>Модифікатор</th>
<th>Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^m</code></td>
<td>Знайти будь-які рядки, які містять m на початку</td>
</tr>
<tr>
<td><code>m$</code></td>
<td>Знайти будь-які рядки, які містять m наприкінці</td>
</tr>
</tbody>
</table>
<p>Давайте перевіримо чи починається текст з Mary:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str1 <span class="op">=</span> <span class="st">&quot;Mary had a little kitten&quot;</span><span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( <span class="ss">/</span><span class="sc">^</span><span class="ss">Mary/</span><span class="op">.</span><span class="fu">test</span>(str1) )<span class="op">;</span> <span class="co">// true</span></span></code></pre></div>
<p>Шаблон <code>^Mary</code> означає: «початок рядка, потім Mary».</p>
<p>Аналогічно можна перевірити, чи закінчується рядок словом fluffy:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str1 <span class="op">=</span> <span class="st">&quot;The kitten was fluffy&quot;</span><span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( <span class="ss">/fluffy</span><span class="sc">$</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(str1) )<span class="op">;</span> <span class="co">// true</span></span></code></pre></div>
<p>Перевіримо, що рядок є часом у форматі <code>12:34</code>, тобто дві
цифри, потім двокрапка, потім ще дві цифри.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> goodInput <span class="op">=</span> <span class="st">&quot;12:34&quot;</span><span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> badInput <span class="op">=</span> <span class="st">&quot;12:345&quot;</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/</span><span class="sc">^\d\d</span><span class="ss">:</span><span class="sc">\d\d$</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( regexp<span class="op">.</span><span class="fu">test</span>(goodInput) )<span class="op">;</span> <span class="co">// true</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( regexp<span class="op">.</span><span class="fu">test</span>(badInput) )<span class="op">;</span> <span class="co">// false</span></span></code></pre></div>
<p>Зверніть увагу: символ <code>^</code> після квадратної дужки має
інший сенс - це ознака початку негативного набору (negative set).</p>
<p>Важливо знати:</p>
<p>Поведінка якорів змінюється, якщо присутній модифікатор
<code>m</code>.</p>
<h2 id="квантифікатори">Квантифікатори</h2>
<p>Квантифікатори дозволяють задати кількість повторень:</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr>
<th>Quantifier</th>
<th>Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>m{X}</code></td>
<td>Знайти будь-які рядки, що містять послідовність m, X разів</td>
</tr>
<tr>
<td><code>m{X, Y}</code></td>
<td>Знайти будь-які рядки, що містять послідовність m, від X до Y
разів</td>
</tr>
<tr>
<td><code>m{X,}</code></td>
<td>Знайти будь-які рядки, що містять послідовність m як мінімум X
разів</td>
</tr>
</tbody>
</table>
<p>Найпростіший квантифікатор — це число у фігурних дужках:
<code>{n}</code>. Він додається до символу (або символьного класу, або
набору) і вказує скільки символів або наборів нам потрібно.</p>
<p>Шаблон <code>\d{5}</code> позначає рівно 5 цифр, він еквівалентний
<code>\d\d\d\d\d</code>.</p>
<p>Наступний приклад знаходить п'ятизначне число:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;I&#39;m 12345 years old&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">\d{5}</span><span class="ss">/</span>) )<span class="op">;</span> <span class="co">// &quot;12345&quot;</span></span></code></pre></div>
<p>Ми можемо додати <code>\b</code>, щоб виключити числа довші:
<code>\b\d{5}\b</code>.</p>
<p>Для того, щоб знайти числа від 3 до 5 цифр, ми можемо вказати межі у
фігурних дужках: <code>\d{3,5}</code></p>
<p>Для найбільш затребуваних квантифікаторів є скорочені форми
запису:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Квантифікатор</th>
<th>Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>n+</code></td>
<td>Означає «один або більше». Те саме, що й <code>{1,}</code></td>
</tr>
<tr>
<td><code>n?</code></td>
<td>Означає «нуль або один». Те саме, що й <code>{0,1}</code>. По суті
робить символ необов'язковим</td>
</tr>
<tr>
<td><code>n*</code></td>
<td>Означає «нуль або більше». Те саме, що й <code>{0,}</code>. Тобто
символ може повторюватися багато разів або взагалі бути відсутнім</td>
</tr>
</tbody>
</table>
<p>Квантифікатори використовуються дуже часто. Вони є основними
«будівельними блоками» складних регулярних виразів.</p>
<h2 id="методи-рядків">Методи рядків</h2>
<p>Як мовилося раніше, використання регулярних висловів інтегровано у
методи рядків.</p>
<h3 id="str.match">str.match</h3>
<p>Метод <code>str.match(regexp)</code> для рядка <code>str</code>
повертає збіги з регулярним виразом <code>regexp</code>.</p>
<p>У нього є три режими роботи:</p>
<ol type="1">
<li>Якщо у регулярного виразу є модифікатор <code>g</code>, він повертає
масив всіх збігів</li>
<li>Якщо такого модифікатору немає, то повертає лише перший збіг у
вигляді масиву, в якому за індексом 0 знаходиться збіг, і є властивості
з додатковою інформацією про нього</li>
<li>І, нарешті, якщо збігів немає, то, незалежно від наявності
<code>g</code>, повертається <code>null</code>.</li>
</ol>
<p>Це важливий аспект. За відсутності збігів повертається не порожній
масив, а саме <code>null</code>. Якщо про це забути, можна легко
припуститися помилки, наприклад:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> matches <span class="op">=</span> <span class="st">&quot;JavaScript&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/HTML/</span>)<span class="op">;</span> <span class="co">// = null</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span>matches<span class="op">.</span><span class="at">length</span>) { <span class="co">// Помилка: у null немає властивості length</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Помилка у рядку вище&quot;</span>)<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Якщо хочеться, щоб результатом завжди був масив, можна написати
так:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> matches <span class="op">=</span> <span class="st">&quot;JavaScript&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/HTML/</span>) <span class="op">||</span> []<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span>matches<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Збігів немає&quot;</span>)<span class="op">;</span> <span class="co">// тепер працює</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="str.matchall">str.matchAll</h3>
<p>Метод <code>str.matchAll(regexp)</code> - "новий, покращений" варіант
методу <code>str.match</code>.</p>
<p>Він використовується, в першу чергу, для пошуку всіх збігів разом із
групами скобок.</p>
<p>Важливо знати:</p>
<p>Ця можливість була додана в мову нещодавно. У старих браузерах може
знадобитися поліфіл.</p>
<p>У нього 3 відмінності від <code>match</code>:</p>
<ul>
<li>Він повертає не масив, а об'єкт, що перебирається з результатами,
звичайний масив можна зробити за допомогою <code>Array.from</code>.</li>
<li>Кожен збіг повертається у вигляді масиву зі скобочними групами (як
<code>str.match</code> без <code>g</code>).</li>
<li>Якщо збігів немає, то повертається не <code>null</code>, а порожній
об'єкт, що перебирається.</li>
</ul>
<p><strong>Приклад</strong></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&#39;&lt;h1&gt;Hello, world!&lt;/h1&gt;&#39;</span><span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/&lt;</span><span class="sc">(</span><span class="ss">.</span><span class="sc">*?)</span><span class="ss">&gt;/g</span><span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> matchAll <span class="op">=</span> str<span class="op">.</span><span class="fu">matchAll</span>(regexp)<span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(matchAll)<span class="op">;</span> </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">// [object RegExp String Iterator], не масив, а об&#39;єкт, що перебирається</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>matchAll <span class="op">=</span> <span class="bu">Array</span><span class="op">.</span><span class="fu">from</span>(matchAll)<span class="op">;</span> <span class="co">// тепер масив</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> firstMatch <span class="op">=</span> matchAll[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( firstMatch[<span class="dv">0</span>] )<span class="op">;</span>  <span class="co">// &lt;h1&gt;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( firstMatch[<span class="dv">1</span>] )<span class="op">;</span>  <span class="co">// h1</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( firstMatch<span class="op">.</span><span class="at">index</span> )<span class="op">;</span>  <span class="co">// 0</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( firstMatch<span class="op">.</span><span class="at">input</span> )<span class="op">;</span>  <span class="co">// &lt;h1&gt;Hello, world!&lt;/h1&gt;</span></span></code></pre></div>
<p>При переборі результатів <code>matchAll</code> у циклі
<code>for..of</code> виклик <code>Array.from</code>, зрозуміло, не
потрібен.</p>
<h3 id="str.search">str.search</h3>
<p>Метод <code>str.search(regexp)</code> повертає позицію першого збігу
з <code>regexp</code> у рядку <code>str</code> або -1, якщо збігу
немає.</p>
<p><strong>Приклад</strong></p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;I love JavaScript!&quot;</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/Java.</span><span class="sc">+</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str<span class="op">.</span><span class="fu">search</span>(regexp))<span class="op">;</span> <span class="co">// 7</span></span></code></pre></div>
<p>Важливе обмеження: <code>str.search</code> вміє повертати лише
позицію першого збігу. Всі входження можна знайти, наприклад, за
допомогою <code>str.matchAll(regexp)</code>.</p>
<h3 id="str.replace">str.replace</h3>
<p>Метод <code>str.replace(regexp, replacement)</code> замінює збіги з
<code>regexp</code> у рядку <code>str</code> на <code>replacement</code>
(всі, якщо є модифікатор <code>g</code>, інакше тільки перше).</p>
<p><strong>Приклад</strong></p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;We will, we will&quot;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/we/i</span><span class="op">,</span> <span class="st">&quot;I&quot;</span>))<span class="op">;</span> <span class="co">// I will, we will</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;We will, we will&quot;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/we/ig</span><span class="op">,</span> <span class="st">&quot;I&quot;</span>))<span class="op">;</span> <span class="co">// I will, I will</span></span></code></pre></div>
<iframe src="examples/ex10.html" width="100%" frameborder="0">
</iframe>
<p>У рядку заміни <code>replacement</code> ми можемо використовувати
спеціальні комбінації символів для вставки фрагментів збігу:</p>
<table>
<thead>
<tr>
<th>Спецсимволи</th>
<th>Дія у рядку заміни</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$&amp;</code></td>
<td>вставляє весь знайдений збіг</td>
</tr>
<tr>
<td><code>$`</code></td>
<td>вставляє частину рядка до збігу</td>
</tr>
<tr>
<td><code>$'</code></td>
<td>вставляє частину рядка після збігу</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>вставляє вміст n-ї групи регулярного виразу</td>
</tr>
<tr>
<td><code>$&lt;name&gt;</code></td>
<td>вставляє вміст групи з ім'ям <code>name</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>вставляє символ "$"</td>
</tr>
</tbody>
</table>
<p><strong>Приклад</strong></p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;I love HTML&quot;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/HTML/</span><span class="op">,</span> <span class="st">&quot;$&amp; и JavaScript&quot;</span>) )<span class="op">;</span> </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">// I love HTML и JavaScript</span></span></code></pre></div>
<iframe src="examples/ex9.html" width="100%" frameborder="0">
</iframe>
<p>Для ситуацій, які вимагають «розумних» замін, другим аргументом може
бути функція. Вона буде викликатись для кожного збігу, і її результат
буде вставлений як заміна.</p>
<h2 id="методи-regexp">Методи RegExp</h2>
<h3 id="regexp.test">regexp.test</h3>
<p>Метод <code>regexp.test(str)</code> перевіряє, чи є хоч один збіг,
якщо так, то повертає <code>true</code>, інакше <code>false</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;I LoVe JavaScript&quot;</span><span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/love/i</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(regexp<span class="op">.</span><span class="fu">test</span>(str))<span class="op">;</span> <span class="co">// true</span></span></code></pre></div>
<p>Вам не обов'язково спочатку поміщати регулярний вираз у змінну:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="ss">/love/i</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&quot;I LoVe JavaScript&quot;</span>))<span class="op">;</span> <span class="co">// true</span></span></code></pre></div>
<h3 id="regexp.exec">regexp.exec</h3>
<p>Метод <code>regexp.exec(str)</code> шукає збіг з <code>regexp</code>
у рядку <code>str</code>.</p>
<p>Метод <code>exec</code> поводиться по-різному залежно від цього, чи
має регулярне вираз модифікатор <code>g</code>.</p>
<ul>
<li>Якщо немає <code>g</code>, то <code>regexp.exec(str)</code> повертає
перший збіг точно як <code>str.match(regexp)</code>. Така поведінка не
дає нам нічого нового.</li>
<li>Якщо є <code>g</code>, то:
<ul>
<li>Виклик <code>regexp.exec(str)</code> повертає перший збіг і
запам'ятовує позицію після нього як <code>regexp.lastIndex</code>.</li>
<li>Наступний такий виклик починає пошук з позиції
<code>regexp.lastIndex</code>, повертає наступний збіг і запам'ятовує
позицію після нього в <code>regexp.lastIndex</code>.</li>
<li>І так далі</li>
<li>Якщо збігів більше немає, то <code>regexp.exec</code> повертає
<code>null</code>, а для <code>regexp.lastIndex</code> встановлюється
значення 0.</li>
</ul></li>
</ul>
<p>До появи методу <code>str.matchAll</code> у JavaScript, виклик
<code>regexp.exec</code> використовували для отримання всіх збігів з
їхніми позиціями та групами дужок у циклі.</p>
<p>Ми можемо використовувати <code>regexp.exec</code> для пошуку збігу,
починаючи з потрібної позиції, якщо вручну поставимо
<code>lastIndex</code>.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="st">&#39;Hello, world!&#39;</span><span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regexp <span class="op">=</span> <span class="ss">/</span><span class="sc">\w+</span><span class="ss">/g</span><span class="op">;</span> <span class="co">// без g властивість lastIndex ігнорується</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>regexp<span class="op">.</span><span class="at">lastIndex</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// шукаємо з 5-ї позиції (тобто з коми і далі)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( regexp<span class="op">.</span><span class="fu">exec</span>(str) )<span class="op">;</span> <span class="co">// world</span></span></code></pre></div>
<h2 id="тестування-регулярних-виразів">Тестування регулярних
виразів</h2>
<p>Існує кілька зручних інструментів для тестування та візуалізації
регулярних виразів.</p>
<p><a href="https://regexper.com/">Regexper</a> - інструмент з відкритим
кодом, який працює прямо в браузері без необхідності встановлення. Він
допомагає зрозуміти, як працює регулярний вираз, перетворюючи його на
наочну діаграму (Railroad Diagram).</p>
<p><strong>Приклад</strong></p>
<p>У Javascript є два види коментарів: <code>//</code> и
<code>/*...*/</code>. Регулярний вираз для пошуку коментарів можна
візуалізувати:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/</span><span class="sc">\/\*[\s\S]*?\*\/|\/\/</span><span class="ss">.</span><span class="sc">*</span><span class="ss">/</span></span></code></pre></div>
<p><img src="regexp-comments.png" width="400" /></p>
<p>Діаграми корисні для пошуку помилок у своїх регулярних виразах та
полегшують модифікацію складних виразів, написаних іншими авторами.</p>
<p><a href="https://regex101.com/">regex101</a> - ще один популярний
онлайн-сервіс, що допомагає створювати та налагоджувати регулярні
вирази. Він пропонує покрокове пояснення збігів та підсвічування
синтаксису, надає довідкові матеріали щодо синтаксису регулярних
виразів.</p>
<p>Головна користь цих інструментів - миттєвий зворотний зв'язок. Вони
підсвічують збіги та пояснюють, чому якісь частини шаблону не
спрацювали.</p>
<h2 id="повний-довідник-з-регулярних-виразів">Повний довідник з
регулярних виразів</h2>
<p>Повну інформацію можна знайти у нашому Повному довіднику з регулярних
виразів JavaScript.</p>
<p>todo: дати посилання</p>
<h2 id="корисні-практичні-приклади">Корисні практичні приклади</h2>
<h3 id="замінити-множинні-пробіли-на-один">Замінити множинні пробіли на
один</h3>
<div class="sourceCode" id="cb31"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> text <span class="op">=</span> <span class="st">&quot;many    spaces    here&quot;</span><span class="op">;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(text<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\s+</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39; &#39;</span>))<span class="op">;</span> </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">// результат: &quot;many spaces here&quot;</span></span></code></pre></div>
<h3 id="витяг-певних-даних-із-рядка">Витяг певних даних із рядка</h3>
<p>Давайте витягнемо всі числа з тексту.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> regex <span class="op">=</span> <span class="ss">/</span><span class="sc">\d+</span><span class="ss">/g</span><span class="op">;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res <span class="op">=</span> <span class="st">&quot;Pinocchio had 1 alphabet and 30 soldi&quot;</span><span class="op">.</span><span class="fu">match</span>(regex)<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(res)<span class="op">;</span></span></code></pre></div>
<h2 id="faq-за-регулярними-виразами">FAQ за регулярними виразами</h2>
<h3 id="у-чому-різниця-між-match-та-exec">У чому різниця між match() та
exec()?</h3>
<p><code>match()</code> - це метод рядка, <code>exec()</code> - це метод
регулярного виразу.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> text <span class="op">=</span> <span class="st">&quot;test1 test2&quot;</span><span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">// match() повертає всі збіги відразу</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(text<span class="op">.</span><span class="fu">match</span>(<span class="ss">/test</span><span class="sc">\d</span><span class="ss">/g</span>))<span class="op">;</span> <span class="co">// [&#39;test1&#39;, &#39;test2&#39;]</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">// exec() повертає по одному збігу за виклик</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="ss">/test</span><span class="sc">\d</span><span class="ss">/g</span><span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(regex<span class="op">.</span><span class="fu">exec</span>(text))<span class="op">;</span> <span class="co">// [&#39;test1&#39;]</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(regex<span class="op">.</span><span class="fu">exec</span>(text))<span class="op">;</span> <span class="co">// [&#39;test2&#39;]</span></span></code></pre></div>
<p>Який метод обрати?</p>
<ul>
<li>Використовуйте <code>match()</code> коли потрібно знайти всі збіги
одразу (з флагом <code>g</code>)</li>
<li>Використовуйте <code>exec()</code> коли потрібна детальна інформація
про збіги або коли потрібно обробляти збіги по одному</li>
</ul>
<h3 id="як-зробити-групу-незахоплюючою">Як зробити групу
незахоплюючою?</h3>
<p>Використовуйте <code>(?:...)</code></p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> text <span class="op">=</span> <span class="st">&quot;I love Javascript&quot;</span><span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(text<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">(?</span><span class="ss">:I</span><span class="sc">)</span><span class="ss"> </span><span class="sc">(</span><span class="ss">love</span><span class="sc">)</span><span class="ss">/</span>))<span class="op">;</span> </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">// [&#39;I love&#39;, &#39;love&#39;]</span></span></code></pre></div>
<h3 id="як-обробляти-помилки-під-час-роботи-з-регулярними-виразами">Як
обробляти помилки під час роботи з регулярними виразами?</h3>
<p>Використовуйте конструкцію <code>try/catch</code></p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> userInput <span class="op">=</span> <span class="st">&quot;* (&quot;</span><span class="op">;</span> </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">new</span> <span class="bu">RegExp</span>(userInput)<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>} <span class="cf">catch</span> (e) {</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Некоректний регулярний вираз&quot;</span>)<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Щоб уникнути синтаксичних помилок, перевіряйте регулярні вирази в
спеціальних інструментах (онлайнових тестерах, IDE з підсвічуванням
тощо).</p>
<h3 id="чому-потрібно-екранувати-спецсимволи">Чому потрібно екранувати
спецсимволи?</h3>
<p>Зворотна коса риса використовується для позначення класів символів,
наприклад <code>\d</code>. Це спеціальний символ у регулярних виразах
(як і у звичайних рядках).</p>
<p>Є й інші спеціальні символи, які мають особливе значення у
регулярному вираженні. Вони використовуються для більш складних
пошукових конструкцій. Ось перелік цих символів:
<code>[ ] \ ^ $ . | ? * + ( )</code>.</p>
<p>Допустимо, ми хочемо знайти буквально крапку. Не «будь-який символ»,
а саме крапку.</p>
<p>Щоб використовувати спеціальний символ як звичайний, додайте до нього
зворотну косу рису: <code>\.</code>.</p>
<p>Це називається "екранування символу".</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> price <span class="op">=</span> <span class="st">&quot;$100.50&quot;</span><span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Неправильно: const regex = /$/;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Правильно:</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="ss">/</span><span class="sc">\$</span><span class="ss">/</span><span class="op">;</span></span></code></pre></div>
<p>Круглі дужки також є спеціальними символами, тому якщо нам потрібно
використовувати саме їх, потрібно вказати <code>\(</code>.</p>
<p>Символ косої риси <code>/</code>, так званий "слеш", не є спеціальним
символом, але в JavaScript він використовується для відкриття і закриття
регулярного виразу: <code>/...шаблон.../</code>, тому ми повинні
екранувати його.</p>
<p>Ось як виглядає пошук косої риси:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;/&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">\/</span><span class="ss">/</span>))<span class="op">;</span> <span class="co">// &#39;/&#39;</span></span></code></pre></div>
<p>З іншого боку, якщо ми не використовуємо запис <code>/.../</code>, а
створюємо регулярний вираз, використовуючи <code>new RegExp</code>, тоді
нам не потрібно екранувати косу рису:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>( <span class="st">&quot;/&quot;</span><span class="op">.</span><span class="fu">match</span>(<span class="kw">new</span> <span class="bu">RegExp</span>(<span class="st">&quot;/&quot;</span>)) )<span class="op">;</span> <span class="co">// знаходить /</span></span></code></pre></div>
<h3 id="у-чому-відмінність-крапки-від-ss">У чому відмінність крапки від
\s\S</h3>
<p>Вираз <code>.*</code> не захоплює перехід на новий рядок, на відміну
від <code>\s\S</code>.</p>
</body>
<script src=https://flems.io/flems.html id=flems defer></script>
<script>
		document.getElementById("flems").onload = function() {
			;[].forEach.call(document.querySelectorAll("pre code.language-js"), function(el) {
				el = el.parentNode

				var div = document.createElement("div")
				window.Flems(div, {
					middle        : 60,
					selected: 'b.js',
					editable      : true,
					toolbar       : false,
					shareButton   : true,
					console       : false,
					autoHeight    : true,
					fileTabs      : false,
					files: [{
						name: "a.js",
						content: `
						const output = document.createElement('div');
document.body.appendChild(output);
const originalConsoleLog = console.log;
console.log = function(message) {
    output.innerHTML += message + '<br>';
    originalConsoleLog.apply(console, arguments);
};`},
                                        {       name: "b.js",
						content: el.textContent
					}]
				}, "https://flems.io/flems.html")

				el.parentNode.insertBefore(div, el)
				el.parentNode.removeChild(el)
			})
		}
</script>

</html>
